#version 460

layout(local_size_x = 32, local_size_y = 32) in;

layout(rgba32f, set = 0, binding = 0) uniform image2D outputImage;
layout(set = 0, binding = 1) uniform sampler2D skyboxImage;

layout(set = 0, binding = 2) buffer Dimensions
{
    uint dimX;
    uint dimY;
} dimensions;

layout(set = 0, binding = 3) buffer SceneSettings
{
    mat4 viewMat;
    mat4 viewInverseMat;
    mat4 inverseProjMat;
}sceneSettings;

layout(set = 0, binding = 4) buffer LightSettings
{
    vec4 lightDir;
    vec4 lightCol;
}lightSettings;

const float PI = 3.14159265f;
const int MAX_MARCHING_STEPS = 255;
const float MIN_DIST = 0.0f;
const float MAX_DIST = 100.0f;
const float EPSILON = 0.0001f;
const float INFINITY = 1.0f / 0.0f;

struct Ray
{
    vec3 origin;
    vec3 direction;
    vec3 energy;
};

struct RayHit
{
    vec3 position;
    float distance;
    vec3 normal;
    vec3 color;
};

RayHit CreateRayHit()
{
    RayHit hit;
    hit.position = vec3(0,0,0);
    hit.distance = INFINITY;
    hit.normal = vec3(0,0,0);
    hit.color = vec3(0,0,0);

    return hit;
}

Ray CreateRay(vec3 origin, vec3 direction)
{
    Ray r;
    r.origin = origin;
    r.direction = direction;
    r.energy = vec3(1.0f);
    return r;
}

Ray CreateCameraRay(vec2 uv)
{
    //wpos of the camera
    vec3 origin = sceneSettings.viewInverseMat[3].xyz; //camera pos = 4th column of the view matrix

    vec3 direction = (sceneSettings.inverseProjMat * vec4(uv, 0.0f, 1.0f)).xyz; //invert the pixel coordinate 
    direction = (sceneSettings.viewInverseMat * vec4(direction.xyz, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
};

/*
------------ SDF FUNCTIONS ------------------------
*/
//Sphere
float SphereSDF(vec3 samplePoint, float radius)
{
	return length(samplePoint) - radius;
}

//Ground plane
float GroundPlaneSDF(vec3 samplePoint)
{
	return samplePoint.y;
}

//Box
float BoxSDF(vec3 samplePoint, vec3 dimensions)
{
	vec3 q = abs(samplePoint) - dimensions;
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

//Rounded box
float RoundBoxSDF(vec3 p, vec3 b, float r)
{
	vec3 q = abs(p) - b;
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;
}

//Cylinder
float CylinderSDF(vec3 p, float h, float r)
{
	vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}
/*
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
*/



/*
------------ OPERATIONS ------------------------
*/
//Infinite Repetition (returns a value that needs to be entered into the primitive function)
vec3 OpRep(vec3 p, vec3 c)
{
	//Make sure negative values work so the repetition doesnt start at 0,0,0
	p = abs(p);
    return mod(p + 0.5 * c, c) - 0.5 * c;
}

//Limited repetition
vec3 opRepLim(vec3 p, float c, vec3 l)
{
	//clamp 0,l so the left bottom of the tiling will be at (0,0), not at (-l / 2, l / 2). That way l{2,1,3} will tile 2,1,3 instead of 4,6,2
    return p - c * clamp(round(p / c), vec3(0,0,0), l);
}

///////

//Only keep overlapping geometry
float IntersectSDF(float distA, float distB)
{
	return max(distA, distB);
}

//Add geometry together (Additive)
vec4 AdditiveSDF(float distA, vec3 colA, float distB, vec3 colB)
{
	float val = min(distA, distB);
    if(val == distA)
        return vec4(colA, val);
    else
        return vec4(colB, val);
}

//Only keep non-overlapping geometry (Subtractive)
float SubtractiveSDF(float distA, float distB)
{
	return max(distA, -distB);
}

// float mix(float x, float y, float a)
// {
// 	return (x * (1 - a)) + (y * a);
// }

//Smooth addition
float SmoothAdditiveSDF(float d1, float d2, float k) 
{
    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) - k * h * (1.0 - h);
}

//Smooth subtraction
float SmoothSubtractiveSDF(float d1, float d2, float k) 
{
    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);
    return mix(d2, -d1, h) + k * h * (1.0 - h);
}

//Smooth intersection
float SmoothIntersectionSDF(float d1, float d2, float k) 
{
    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) + k * h * (1.0 - h);
}
/*
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*/

vec4 map(vec3 samplePoint)
{
    //DISTANCE FUNCTIONS
    vec3 objectColor = vec3(0,0,0);
    vec3 redObject = vec3(1,1,1);
    vec3 floorColor = vec3(0,0,0);

    vec3 infRep = opRepLim(samplePoint, 6, vec3(10, 0, 10));
    float sphere = SphereSDF(infRep, 1.0f);

    float ground = GroundPlaneSDF(samplePoint - vec3(0, -12, 0));

    float cSphere = SphereSDF(samplePoint, 2.0f);

    vec4 combined = AdditiveSDF(ground, floorColor, sphere, objectColor);
    vec4 combined2 = AdditiveSDF(combined.w, combined.xyz, cSphere, redObject);

    return combined2;
}

vec3 EstimateNormal(vec3 samplePoint)
{
	vec3 norm = vec3(map(vec3(samplePoint.x + EPSILON, samplePoint.y, samplePoint.z)).w - map(vec3(samplePoint.x - EPSILON, samplePoint.y, samplePoint.z)).w,
						 map(vec3(samplePoint.x, samplePoint.y + EPSILON, samplePoint.z)).w - map(vec3(samplePoint.x, samplePoint.y - EPSILON, samplePoint.z)).w,
						 map(vec3(samplePoint.x, samplePoint.y, samplePoint.z + EPSILON)).w - map(vec3(samplePoint.x, samplePoint.y, samplePoint.z - EPSILON)).w);

	return normalize(norm);
}

RayHit Trace(Ray ray, float start, float end)
{
    float depth = start;
    for(int i = 0; i < MAX_MARCHING_STEPS; ++i)
    {
        vec4 val = map(ray.origin + (depth * ray.direction));
        if(val.w < EPSILON)
        {
            RayHit hit = CreateRayHit();
            hit.position = ray.origin + (ray.direction * depth);
            hit.normal = EstimateNormal(hit.position);
            hit.distance = depth;
            hit.color = val.xyz;
            return hit;
        }

        depth += val.w;
        if(depth >= end)
        {
            return CreateRayHit();
        }
    }

    return CreateRayHit();
}

vec3 Shade(float tracedDistance, Ray ray, vec3 objectColor)
{
    if(tracedDistance > MAX_DIST - EPSILON)
    {
        // Sample the skybox and write it
        float phi = atan(-ray.direction.z, ray.direction.x) / -PI * 0.5f;
        float theta = acos(-ray.direction.y) / -PI;

        vec3 skyboxCol = texture(skyboxImage, vec2(phi, theta)).xyz;
        return skyboxCol;
    }

    vec3 collisionPoint = ray.origin + (ray.direction * tracedDistance);
    vec3 normal = EstimateNormal(collisionPoint);

    //Ambient
    float ambientStrength = 0.3f;
    vec3 ambient = ambientStrength * lightSettings.lightCol.xyz;

    //Diffuse
    float diffuseStrength = max(dot(normal, -lightSettings.lightDir.xyz), 0.0f);
    vec3 diffuse = diffuseStrength * lightSettings.lightCol.xyz;

    //Blinn-phong
    int shininess = 64;
    vec3 lightDir = normalize(lightSettings.lightDir.xyz);
    vec3 camForward = vec3(sceneSettings.viewMat[0][2], sceneSettings.viewMat[1][2], sceneSettings.viewMat[2][2]);
    vec3 halfVec = normalize(-lightDir + camForward);
    float spec = pow(max(dot(halfVec, normal), 0.0f), shininess);
    vec3 specular = spec * lightSettings.lightCol.xyz;
    vec3 resultCol = (ambient + diffuse + specular) * objectColor;

    return resultCol;
}

void main()
{
    if(gl_GlobalInvocationID.x >= dimensions.dimX ||  gl_GlobalInvocationID.y >= dimensions.dimY)
        return;
    
    uvec2 id = gl_GlobalInvocationID.xy;

    uint width = dimensions.dimX;
    uint height = dimensions.dimY;

    //Create the ray from camera position to current pixel (+ (0.5, 0.5) is to get center of pixel)
    vec2 uv = vec2((id.xy + vec2(0.5f, 0.5f)) / vec2(width, height) * 2.0f - 1.0f );
    Ray originalRay = CreateCameraRay(uv);

    //8 ray bounces
    vec3 SPECULAR = vec3(0.6f, 0.6f, 0.6f);
    vec3 finalColor = vec3(0,0,0);
    Ray ray = originalRay; //Backup the original to reflect with
    for(int i = 0; i < 8; ++i)
    {
        RayHit hit = Trace(ray, MIN_DIST, MAX_DIST);
        finalColor += ray.energy * Shade(hit.distance, ray, hit.color);

        if(ray.energy.x <= EPSILON || ray.energy.y <= EPSILON || ray.energy.z <= EPSILON)
        {
            break;
        }

        //Reflect ray
        ray.origin = hit.position + (hit.normal * 0.1f);
        ray.direction = reflect(ray.direction, hit.normal);
        ray.energy *= SPECULAR;
    }

    ivec2 imageUV = ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y));
    imageStore(outputImage, imageUV, vec4(finalColor, 1.0f));
}