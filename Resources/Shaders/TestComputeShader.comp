#version 460

layout(local_size_x = 32, local_size_y = 32) in;

layout(rgba32f, set = 0, binding = 0) uniform image2D outputImage;
layout(set = 0, binding = 1) uniform sampler2D skyboxImage;

layout(set = 0, binding = 2) buffer Dimensions
{
    uint dimX;
    uint dimY;
} dimensions;

layout(set = 0, binding = 3) buffer SceneSettings
{
    mat4 viewMat;
    mat4 viewInverseMat;
    mat4 inverseProjMat;
    float time;
}sceneSettings;

layout(set = 0, binding = 4) buffer LightSettings
{
    vec4 lightDir;
    vec4 lightCol;
}lightSettings;

const float PI = 3.14159265f;
const int MAX_MARCHING_STEPS = 255;
const float MIN_DIST = 0.0f;
const float MAX_DIST = 100.0f;
const float EPSILON = 0.0001f;
const float INFINITY = 1.0f / 0.0f;

struct Ray
{
    vec3 origin;
    vec3 direction;
    vec3 energy;
};

struct RayHit
{
    vec3 position;
    float distance;
    vec3 normal;
    vec3 color;
    vec3 specular;
};

RayHit CreateRayHit()
{
    RayHit hit;
    hit.position = vec3(0,0,0);
    hit.distance = INFINITY;
    hit.normal = vec3(0,0,0);
    hit.color = vec3(0,0,0);
    hit.specular = vec3(1,1,1);

    return hit;
}

Ray CreateRay(vec3 origin, vec3 direction)
{
    Ray r;
    r.origin = origin;
    r.direction = direction;
    r.energy = vec3(1.0f);
    return r;
}

Ray CreateCameraRay(vec2 uv)
{
    //wpos of the camera
    vec3 origin = sceneSettings.viewInverseMat[3].xyz; //camera pos = 4th column of the view matrix

    vec3 direction = (sceneSettings.inverseProjMat * vec4(uv, 0.0f, 1.0f)).xyz; //invert the pixel coordinate 
    direction = (sceneSettings.viewInverseMat * vec4(direction.xyz, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
};

struct SceneObject
{
    float value;
    vec3 color;
    vec3 specular;
};

SceneObject CreateSceneObject(float val, vec3 col, vec3 spec)
{
    SceneObject newObject;
    newObject.value = val;
    newObject.color = col;
    newObject.specular = spec;
    return newObject;
}

/*
------------ SDF FUNCTIONS ------------------------
*/
//Sphere
float SphereSDF(vec3 samplePoint, float radius)
{
	return length(samplePoint) - radius;
}

//Ground plane
float GroundPlaneSDF(vec3 samplePoint)
{
	return samplePoint.y;
}

//Box
float BoxSDF(vec3 samplePoint, vec3 dimensions)
{
	vec3 q = abs(samplePoint) - dimensions;
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

//Rounded box
float RoundBoxSDF(vec3 p, vec3 b, float r)
{
	vec3 q = abs(p) - b;
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;
}

//Cylinder
float CylinderSDF(vec3 p, float h, float r)
{
	vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}
/*
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
*/



/*
------------ OPERATIONS ------------------------
*/
//Infinite Repetition (returns a value that needs to be entered into the primitive function)
vec3 OpRep(vec3 p, vec3 c)
{
	//Make sure negative values work so the repetition doesnt start at 0,0,0
	p = abs(p);
    return mod(p + 0.5 * c, c) - 0.5 * c;
}

//Limited repetition
vec3 opRepLim(vec3 p, float c, vec3 l)
{
	//clamp 0,l so the left bottom of the tiling will be at (0,0), not at (-l / 2, l / 2). That way l{2,1,3} will tile 2,1,3 instead of 4,6,2
    return p - c * clamp(round(p / c), vec3(0,0,0), l);
}

///////

//Only keep overlapping geometry
SceneObject IntersectSDF(SceneObject d1, SceneObject d2)
{
	float val = max(d1.value, d2.value);

    vec3 col;
    val == d1.value ? col = d1.color : col = d2.color;

    vec3 spec;
    val == d1.value ? spec = d1.specular : spec = d2.specular;

    return CreateSceneObject(val, col, spec);
}

//Add geometry together (Additive)
SceneObject AdditiveSDF(SceneObject d1, SceneObject d2)
{
	float val = min(d1.value, d2.value);

    vec3 col;
    val == d1.value ? col = d1.color : col = d2.color;

    vec3 spec;
    val == d1.value ? spec = d1.specular : spec = d2.specular;

    return CreateSceneObject(val, col, spec);
}

//Only keep non-overlapping geometry (Subtractive)
SceneObject SubtractiveSDF(SceneObject d1, SceneObject d2)
{
	float val = max(d1.value, -d2.value);

    vec3 col;
    val == d1.value ? col = d1.color : col = d2.color;

    vec3 spec;
    val == d1.value ? spec = d1.specular : spec = d2.specular;

    return CreateSceneObject(val, col, spec);
}

//Smooth addition
SceneObject SmoothAdditiveSDF(SceneObject d1, SceneObject d2, float k) 
{
    float h = clamp(0.5 + 0.5 * (d2.value - d1.value) / k, 0.0, 1.0);
    
    float val = mix(d2.value, d1.value, h) - k * h * (1.0 - h);
    vec3 col = mix(d2.color, d1.color, h);
    vec3 spec = mix(d2.specular, d1.specular, h);

    return CreateSceneObject(val, col, spec);
}

//Smooth subtraction
SceneObject SmoothSubtractiveSDF(SceneObject d1, SceneObject d2, float k) 
{
    float h = clamp(0.5 - 0.5 * (d2.value + d1.value) / k, 0.0, 1.0);

    float val = mix(d2.value, -d1.value, h) + k * h * (1.0 - h);
    vec3 col = mix(d2.color, d1.color, h);
    vec3 spec = mix(d2.specular, d1.specular, h);

    return CreateSceneObject(val, col, spec);
}

//Smooth intersection
SceneObject SmoothIntersectionSDF(SceneObject d1, SceneObject d2, float k) 
{
    float h = clamp(0.5 - 0.5 * (d2.value - d1.value) / k, 0.0, 1.0);

    float val = mix(d2.value, d1.value, h) + k * h * (1.0 - h);
    vec3 col = mix(d2.color, d1.color, h);
    vec3 spec = mix(d2.specular, d1.specular, h);

    return CreateSceneObject(val, col, spec);
}
/*
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*/

SceneObject MetaBalls(vec3 samplePoint)
{
    SceneObject ball1;
    SceneObject ball2;
    SceneObject ball3;

    float s = sin(sceneSettings.time) / 1.5f;
    float c = cos(sceneSettings.time) / 1.5f;

    ball1.value = SphereSDF(samplePoint - vec3(s, c, 0), 1.0f);
    ball1.color = vec3(0);
    ball1.specular = vec3(1.0f, 0.74f, 0.34f);

    ball2.value = SphereSDF(samplePoint- vec3(c, 0, s), 1.0f);
    ball2.color = vec3(0);
    ball2.specular = vec3(1.0f, 0.63f, 0.53f);

    ball3.value = SphereSDF(samplePoint- vec3(0, c, s), 1.0f);
    ball3.color = vec3(0);
    ball3.specular = vec3(0.8f, 0.8f, 0.8f);

    SceneObject pass1 = SmoothAdditiveSDF(ball1, ball2, 0.5f);
    SceneObject pass2 = SmoothAdditiveSDF(pass1, ball3, 0.5f);

    return pass2;
}

SceneObject map(vec3 samplePoint)
{
    //DISTANCE FUNCTIONS
    vec3 metalColor = vec3(0, 0, 0);
    vec3 whiteColor = vec3(1.0f, 1.0f, 1.0f);
    vec3 floorColor = vec3(0.1f, 0.1f, 0.1f);

    vec3 goldSpecular = vec3(1.0f, 0.71f, 0.29f);

    SceneObject goldSphere;
    SceneObject whiteSphere;
    SceneObject ground;

    //repetitive spheres (gold)
    vec3 infRep = opRepLim(samplePoint, 6, vec3(10, 0, 10));
    goldSphere.value = SphereSDF(infRep - vec3(0, sin(sceneSettings.time) - 3.0f, 0), 1.0f);
    goldSphere.color = metalColor;
    goldSphere.specular = goldSpecular;

    //Single white sphere
    whiteSphere.value = SphereSDF(samplePoint, 2.0f);
    whiteSphere.color = whiteColor;
    whiteSphere.specular = vec3(1.0f, 1.0f, 1.0f);

    //Ground
    ground.value = GroundPlaneSDF(samplePoint - vec3(0, -3.0f, 0));
    ground.color = floorColor;
    ground.specular = vec3(0.1f, 0.1f, 0.1f);

    //Metaballs
    SceneObject metaBalls = MetaBalls(samplePoint - vec3(-5, 1, -5));

    //Combine everything
    SceneObject combined = SmoothAdditiveSDF(goldSphere, whiteSphere, 0.5f);
    SceneObject combined2 = SmoothAdditiveSDF(combined, ground, 0.5f);
    SceneObject combined3 = AdditiveSDF(combined2, metaBalls);

    return combined3;
}

vec3 EstimateNormal(vec3 samplePoint)
{
	vec3 norm = vec3(map(vec3(samplePoint.x + EPSILON, samplePoint.y, samplePoint.z)).value - map(vec3(samplePoint.x - EPSILON, samplePoint.y, samplePoint.z)).value,
						 map(vec3(samplePoint.x, samplePoint.y + EPSILON, samplePoint.z)).value - map(vec3(samplePoint.x, samplePoint.y - EPSILON, samplePoint.z)).value,
						 map(vec3(samplePoint.x, samplePoint.y, samplePoint.z + EPSILON)).value - map(vec3(samplePoint.x, samplePoint.y, samplePoint.z - EPSILON)).value);

	return normalize(norm);
}

RayHit Trace(Ray ray, float start, float end)
{
    float depth = start;
    for(int i = 0; i < MAX_MARCHING_STEPS; ++i)
    {
        SceneObject val = map(ray.origin + (depth * ray.direction));
        if(val.value < EPSILON)
        {
            RayHit hit = CreateRayHit();
            hit.position = ray.origin + (ray.direction * depth);
            hit.normal = EstimateNormal(hit.position);
            hit.distance = depth;
            hit.color = val.color;
            hit.specular = val.specular;
            return hit;
        }

        depth += val.value;
        if(depth >= end)
        {
            return CreateRayHit();
        }
    }

    return CreateRayHit();
}

vec3 Shade(float tracedDistance, inout Ray ray, vec3 objectColor)
{
    if(tracedDistance > MAX_DIST - EPSILON)
    {
        ray.energy = vec3(0.0f);

        // Sample the skybox and write it
        float phi = atan(-ray.direction.z, ray.direction.x) / -PI * 0.5f;
        float theta = acos(-ray.direction.y) / -PI;

        vec3 skyboxCol = texture(skyboxImage, vec2(phi, theta)).xyz;
        return skyboxCol;
    }

    vec3 collisionPoint = ray.origin + (ray.direction * tracedDistance);
    vec3 normal = EstimateNormal(collisionPoint);

    //Ambient
    float ambientStrength = 0.3f;
    vec3 ambient = ambientStrength * (lightSettings.lightCol.xyz * lightSettings.lightCol.w);

    //Diffuse
    float diffuseStrength = max(dot(normal, -lightSettings.lightDir.xyz), 0.0f);
    vec3 diffuse = diffuseStrength * (lightSettings.lightCol.xyz * lightSettings.lightCol.w);

    //Blinn-phong
    int shininess = 64;
    vec3 lightDir = normalize(lightSettings.lightDir.xyz);
    //vec3 camForward = vec3(sceneSettings.viewMat[0][2], sceneSettings.viewMat[1][2], sceneSettings.viewMat[2][2]);
    vec3 camForward = ray.direction;
    vec3 halfVec = normalize(-lightDir + camForward);
    float spec = pow(max(dot(halfVec, normal), 0.0f), shininess);
    vec3 specular = spec * (lightSettings.lightCol.xyz * lightSettings.lightCol.w);
    vec3 resultCol = (ambient + diffuse + specular) * objectColor;

    return resultCol;
}

void main()
{
    if(gl_GlobalInvocationID.x >= dimensions.dimX ||  gl_GlobalInvocationID.y >= dimensions.dimY)
        return;
    
    uvec2 id = gl_GlobalInvocationID.xy;

    uint width = dimensions.dimX;
    uint height = dimensions.dimY;

    //Create the ray from camera position to current pixel (+ (0.5, 0.5) is to get center of pixel)
    vec2 uv = vec2((id.xy + vec2(0.5f, 0.5f)) / vec2(width, height) * 2.0f - 1.0f );
    Ray originalRay = CreateCameraRay(uv);

    //8 ray bounces
    vec3 SPECULAR = vec3(0.6f, 0.6f, 0.6f);
    vec3 finalColor = vec3(0,0,0);
    Ray ray = originalRay; //Backup the original to reflect with
    for(int i = 0; i < 8; ++i)
    {
        RayHit hit = Trace(ray, MIN_DIST, MAX_DIST);
        finalColor += ray.energy * Shade(hit.distance, ray, hit.color);

        if(ray.energy.x <= EPSILON || ray.energy.y <= EPSILON || ray.energy.z <= EPSILON)
        {
           break;
        }

        //Reflect ray
        ray.origin = hit.position + (hit.normal * 0.1f);
        ray.direction = reflect(ray.direction, hit.normal);
        ray.energy *= hit.specular;
    }

    ivec2 imageUV = ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y));
    imageStore(outputImage, imageUV, vec4(finalColor, 1.0f));
}